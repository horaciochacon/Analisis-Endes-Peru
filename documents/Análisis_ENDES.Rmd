---
title: 'ENDES 2017 en R: ejemplificando la reproducibilidad del análisis de la ENDES'
author: "Akram Hernández, Horacio Chacón"
date: "14 de septiembre de 2018"
output:
  html_document:
    theme: journal
    toc: true
    toc_float: true
bibliography: '../documents/bib/biblio.bib'
csl: '../documents/bib/vancouver.csl'
link-citations: yes
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Descripción

Este es un ejemplo de extracción, unión y análisis de datos reproducible de la **Encuesta Demográfica de Salud Familiar (ENDES)** para el uso particular del cálculo de indicadores de salud tales como Hipertensión arterial y Obesidad.

## 1. Librerías

Cargamos las librerías necesarias para el análisis. El uso de estos paquetes permite ejecutar funciones específicas que no vienen por defecto en los comandos base de R.

```{r cargando_librerias, results='hide', message=FALSE, warning=FALSE}
library(tidyverse)
library(stringr)
library(haven)
library(plyr)
library(survey)
library(kableExtra)
```

En caso no esten instaladas previamente las librerias, instalarlas con el comando install.package().

## 2. Lectura de datos

Antes de poder leer los datos debemos descargarlos desde la web de [INEI] (http://iinei.inei.gob.pe/microdatos/Consulta_por_Encuesta.asp). En este caso utilizaremos las bases **CSALUD01, RE223132, REC42, RECH1, RECH23, RECH0**. Estas bases pueden ser encontradas en los módulos **64, 65, 67, 70 y 414**.

![*Imagen 1: Página de consulta de las bases de datos de la ENDES (INEI)*](fig/INEI.PNG){width=100%}

Opcionalmente ponemos a su disposición la librería [ENDES.PE](https://github.com/horaciochacon/ENDES.PE) con el comando *consulta_endes()*. Para instalarlo ejecutar:

devtools::install_github(horaciochacon/ENDES.PE)

```{r instalar_ENDES.PE,eval = F, echo= T}

devtools::install_github(horaciochacon/ENDES.PE)

library(ENDES.PE)
```

Utilizando este comando podemos también descargar las bases de datos necesarias:

```{r consulta_endes, eval=F, echo=T}
consulta_endes(periodo = 2017, codigo_modulo = 64, base = "RECH0", guardar = TRUE, ruta = "data")
consulta_endes(periodo = 2017, codigo_modulo = 64, base = "RECH1", guardar = TRUE, ruta = "data")
consulta_endes(periodo = 2017, codigo_modulo = 65, base = "RECH23", guardar = TRUE, ruta = "data")
consulta_endes(periodo = 2017, codigo_modulo = 67, base = "RE223132", guardar = TRUE, ruta = "data")
consulta_endes(periodo = 2017, codigo_modulo = 70, base = "REC42", guardar = TRUE, ruta = "data")
consulta_endes(periodo = 2017, codigo_modulo = 414, base = "CSALUD01", guardar = TRUE, ruta = "data")
```


Una vez descargados los archivos en formato **.sav** (SPSS), debemos guardarlos en una carpeta de facil acceso. Para facilidad de consulta, nosotros la guardaremos en la carpeta **/data/** de nuestra raiz de proyecto. Para mantener orden en el proceso usamos la siguiente estructura de carpeta.

![*Imagen 2: Estructura de archivos del proyecto*](fig/estructura.PNG){width=100%}

Una vez preparados los archivos procedemos a la importación de cada una de las bases con el comando **read_spss()** del paquete *Haven*. Nótese que las bases de datos se cargan automáticamente al formato Tibble [@wickham2016r] 


```{r lectura, results='hide', message=FALSE, warning=FALSE}
CSALUD01        <- read_sav("../data/CSALUD01.sav", encoding = 'UTF-8')
MUJER_RE223132  <-  read_sav("../data/RE223132.SAV", encoding = 'UTF-8')
MUJER_REC42     <-  read_sav("../data/REC42.SAV", encoding = 'UTF-8')
PERSONA_RECH1   <-  read_sav("../data/RECH1.SAV", encoding = 'UTF-8')
VIVIENDA_RECH23 <-  read_sav("../data/RECH23.SAV", encoding = 'UTF-8')
HOGAR_RECH0     <-  read_sav("../data/RECH0.SAV", encoding = 'UTF-8')
```


## 3. Preparación de las bases

Para poder unir las bases de datos es necesario  crear nuevas variables para luego poder hacer una unión (merge) satisfactorio entre las distintas bases. La unión se basa en dos identificadores que son *HHID* y *QSNUMERO*. En las bases que se carezca de una u otra de estas variables se deberá, como se demuestra a continuación, generarlas.

La estructura de unión puede observarse en la siguiente tabla.

![*Tabla 1: Estructura de Unión*](fig/Tabla.png){width = 100%}

En **MUJER_RE223132** creamos *HHID* y *QSNUMERO*. Para obtenerlos debemos entender que *HHID* es la subcadena de texto sin los 3 últimos caracteres de CASEID. Por otro lado, *QSNUMERO* es la subcadena restante (2 últimos caracteres) de la variable *CASEID*. Para extraer subcadenas de texto utilizamos el comando **str_sub()**:

```{r stringr_1}

MUJER_RE223132$HHID <- str_sub(MUJER_RE223132$CASEID,1,(str_length(MUJER_RE223132$CASEID)-3))
MUJER_RE223132$QSNUMERO <- str_sub(MUJER_RE223132$CASEID,-2,-1)
MUJER_RE223132$QSNUMERO <- as.numeric(MUJER_RE223132$QSNUMERO)
```

De la misma forma, en **MUJER_REC42** creamos *HHID* y *QSNUMERO* para poder facilitar la unión de las bases posteriormente:

```{r stringr_2}
MUJER_REC42$HHID <- str_sub(MUJER_REC42$CASEID,1,(str_length(MUJER_REC42$CASEID)-3))
MUJER_REC42$QSNUMERO <- str_sub(MUJER_REC42$CASEID,-2,-1)
MUJER_REC42$QSNUMERO <- as.numeric(MUJER_REC42$QSNUMERO)
```


En RECH1, la variable *HVIDX* es equivalente a *QSNUMERO* (el identificador de fila o individuo). Por eso, la renombramos con el siguiente comando: 

```{r generando_llaves}
PERSONA_RECH1$QSNUMERO <- PERSONA_RECH1$HVIDX
```

## 4. Unión de Datos 

Cada una de estas bases contiene campos necesarios para obtener la base final que nos permitirá calcular los indicadores. Para poder referenciar entre una base y otra existen identificadores (mencionados previamente) en las diferentes bases. Estos identificadores, según el nivel de desagregación de cada base permiter unirlas relacionalmente.

Esta unión será realizada secuencialmente, creando bases intermedias, hasta conseguir una base de datos que englobe todas las variables requeridas.

Empezamos juntando las bases PERSONA_RECH1 y CSALUD01 en la base intermediaria **BASE1**. El comando utilizado es **join()** tomando como parametro muy importante el '*Left Join*' [@wiki:join}]. Las variables enlace para la unión o join son tanto *HHID* como *QSNUMERO*. Hacemos lo mismo con el resto de de bases hasta tener una **BASE5**.

```{r union}
BASE1 <- left_join(PERSONA_RECH1, CSALUD01, by = c("HHID","QSNUMERO"))
BASE2 <- left_join(MUJER_RE223132, MUJER_REC42, by = c("HHID", "QSNUMERO"))
BASE3 <- left_join(HOGAR_RECH0, VIVIENDA_RECH23, by = "HHID")
BASE4 <- left_join(BASE1,BASE2,by = c("HHID","QSNUMERO"))
BASE5 <- left_join(BASE3,BASE4,by = 'HHID')
```

## 5. Aplicación de los filtros

Podemos corroborar cuantas observaciones tiene nuestra **BASE5**.

```{r conteo}
nrow(BASE5)
```

Ahora es momento de aplicar los filtros necesario para quedarnos solamente con los sujetos necesarios para el análisis. En primer lugar descartamos a todas las gestantes (**V213**) y luego filtramos a solamente los informantes cuya información haya sido reportada como completa (**QSRESINF**).

```{r filtros}
BASE_FINAL <- filter(BASE5,V213!= 1 | is.na(V213))
BASE_FINAL <- filter(BASE_FINAL,QSRESINF == 1)
```

La población final que tiene nuestra **BASE_FINAL** es de:

```{r conteo_2}
nrow(BASE_FINAL)
```

Borramos los objetos creados que ya no utilizaremos para el análisis.

```{r limpia_enviroment}
rm(CSALUD01,BASE1,BASE2,BASE3,BASE4,BASE5,PERSONA_RECH1,HOGAR_RECH0,VIVIENDA_RECH23,MUJER_REC42,MUJER_RE223132)
```


## 6. Creación de Variables

Teniendo ya nuestra **BASE_FINAL**, es necesario crear las variables necesarias para el análisis descriptivo de obesidad e hipertensión que deseamos realizar.

### 6.1 Presión Arterial

Empezamos calculando la presión arterial sistólica y diastólica para luego elaborar dos variables dicotómicas complementarias, hipertensión arterial (según JNC) y presión arterial ideal:


```{r PA}
#Generando valores promedio de la PA sistólica
BASE_FINAL$PAMS <-(BASE_FINAL$QS905S+BASE_FINAL$QS903S)/2

#Generando valores promedio de la PA diastólica
BASE_FINAL$PAMD <-(BASE_FINAL$QS905D+BASE_FINAL$QS903D)/2

#Generando la variable HTA y HTA ideal
BASE_FINAL$HTA_JNC <-(BASE_FINAL$PAMS>=140) | (BASE_FINAL$PAMD>=90)
BASE_FINAL$HTA_ideal <- (BASE_FINAL$PAMS<120) | (BASE_FINAL$PAMD<80)
```


### 6.2 Peso, Talla e IMC

Un indicador salud cardiovascular ideal es un **Índice de Masa Corporal (IMC)** menor de 25. Para eso procesamos las variables peso y talla (ubicadas en distintos lugares según el sujeto) para luego calcular el IMC:


```{r Obesidad, warning=FALSE}

# Dado que tenemos dos variables para peso (V437 y QS900) Validamos que no hay dos mediciones de peso distintas en un mismo sujeto
table(!is.na(BASE_FINAL$V437),!is.na(BASE_FINAL$QS900))

#Creamos una variable única para el peso (Nótese que V437 está elevada a un factor de 10, por lo que se reconvierte)
BASE_FINAL$PESO <- ifelse(!is.na(BASE_FINAL$V437),BASE_FINAL$V437/10,
                          ifelse(!is.na(BASE_FINAL$QS900),BASE_FINAL$QS900,NA))

# Comprobamos gráficamente los datos la coherencia de los datos
ggplot(data=BASE_FINAL, mapping = aes(x=factor(BASE_FINAL$HV104),y=PESO)) + geom_boxplot() + xlab("Sexo")

# Al igual que el peso, la talla está en dos variables distintas (V438 y QS901). Comprobamos que no haya duplicidad de mediciones. 
table(!is.na(BASE_FINAL$V438),!is.na(BASE_FINAL$QS901))

#Creamos una variable única para el talla (Nótese que V438 está elevada a un factor de 10, por lo que se reconvierte)
BASE_FINAL$TALLA <- ifelse(!is.na(BASE_FINAL$V438),BASE_FINAL$V438/10,
                           ifelse(!is.na(BASE_FINAL$QS901),BASE_FINAL$QS901,NA))

# Comprobamos gráficamente los datos la coherencia de los datos

ggplot(data=BASE_FINAL, mapping = aes(x=factor(BASE_FINAL$HV104),y=TALLA)) + geom_boxplot() + xlab("Sexo")

# Generamos la Variable IMC, Obesidad e IMC ideal
BASE_FINAL$IMC <- BASE_FINAL$PESO/(BASE_FINAL$TALLA/100)^2
BASE_FINAL$Obesidad <- ifelse(BASE_FINAL$IMC>=30,TRUE,FALSE)
BASE_FINAL$IMC_ideal <- ifelse(BASE_FINAL$IMC<25,TRUE,FALSE)

# Nuevamente, comprobamos gráficamente los datos la coherencia de los datos

ggplot(data= filter(BASE_FINAL,IMC<100), mapping = aes(x=factor(HV104),y=IMC)) + geom_boxplot() + xlab("Sexo")

```

### 6.3 Edad y Grupos etáreos

Aunque no directamente relacionado con los indicadores, una variable de gran interes es la edad, la cual necesita algunas modificaciones para poder ser utilizada correctamente durante el análisis:

```{r edad_grupoetareo}

# Corregimos la variable edad ya que está como factor
BASE_FINAL$HV105 <- as.character(BASE_FINAL$HV105)
BASE_FINAL$HV105 <- ifelse(BASE_FINAL$HV105 == '97+','97',BASE_FINAL$HV105)
BASE_FINAL$HV105 <- as.numeric(BASE_FINAL$HV105)

#Elaboramos los grupos etareos
BASE_FINAL$grupo_etareo <-  cut(BASE_FINAL$HV105, breaks = c(0,15,25,35,45,55,65,100),
                                right = F,labels = c('0-14','15-24','25-34','35-44','45-54','55-65','65+'))

```

## 7. Creación de la base lista

Ahora que tenemos todas las variables creadas, procedemos a crear un Data Frame final con solamente las variables importantes para el análisis. Entre estas están el sexo, Area urbano/rural, edad, grupos etáreos, Area de residencia, nivel educativo, quintil de bienestar, entre otros:

<<<<<<< HEAD
```{r base_lista}
SALUD_CV <- select(BASE_FINAL, HHID, QSNUMERO,HV001, HV022, PESO15_AMAS,sexo = HV104, edad = HV105,
                   grupo_etareo, urb_rur = HV025, nivel_educativo = HV106,HV270,HV271, 
                   anos_estudio = HV108, region_natural = SHREGION, departamento = HV024, 
                   estado_civil = HV115,seguro_salud = QS27,HTA_JNC,HTA_ideal, PESO, TALLA, IMC, IMC_ideal,
                   Obesidad)
```


Finalmente, guardamos la base en nuestra carpeta /data_output/ para mantener la trazabilidad de los datos. A partir de este momento empezará el análisis.

```{r write_csv, eval=F, echo=T}
write.csv(SALUD_CV, '../data_output/SALUD_CV.csv')
```

## 8. Análisis

Para poder realizar el análisis, ya que estamos calculando indicadores de una encuesta con ponderaciones específicas, utilizamos la metodología descrita para el analisis de DHS por Vanderels y Speybroeck [@vanderelst2014loading]. Creamos mediante el paquete *survey* [@lumley2011complex]. Mediante este paquete especificamos el diseño del estudio mediante los parámetros:

1. La unidad de muestreo (*HV001*)
2. La unidad de conglomerado o estrato (*HV002*)
3. La ponderación (*PESO15_AMAS*)

```{r diseño}
design <-svydesign(id=~HV001, strata=~HV022, weights=~PESO15_AMAS, data=SALUD_CV)
```

Con esta ponderación podemos ahora calcular la proporción de personas con Hipertensión arterial ideal según varios factores:

```{r proporcion_salud}

svyby(~HTA_JNC,by=~grupo_etareo,design = design,FUN=svyciprop,vartype=c('se','ci')) %>% 
  kable() %>% kable_styling()
svyby(~HTA_JNC,by=~urb_rur,design = design,FUN=svyciprop,vartype=c('se','ci')) %>% 
  kable() %>% kable_styling()
svyby(~HTA_JNC,by=~region_natural,design = design,FUN=svyciprop,vartype=c('se','ci')) %>% 
  kable() %>% kable_styling()
svyby(~HTA_JNC,by=~sexo,design = design,FUN=svyciprop,vartype=c('se','ci')) %>% 
  kable() %>% kable_styling()
svyby(~HTA_JNC,by=~nivel_educativo,design = design,FUN=svyciprop,vartype=c('se','ci')) %>% 
  kable() %>% kable_styling()
```

Podemos Incluso crear un gráfico con intervalos de confianza para representar mejor los hallazgos:

```{r grafico_tabla_quintil}

quintil_bienestar <- svyby(~HTA_JNC,by=~HV270,design = design,FUN=svyciprop,vartype=c('se','ci'))

quintil_bienestar %>%
  kable() %>%
  kable_styling()

ggplot(quintil_bienestar, aes(x = HV270, y = HTA_JNC)) +
  geom_point(size = 4) +
  geom_errorbar(aes(ymax = ci_u, ymin = ci_l))+
  xlab('Quintil de Bienestar') + 
  ylab('Proporción personas con HTA')
```


# Bibliografía








